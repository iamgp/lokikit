"""Utilities for generating Grafana dashboards from log data."""

import json
import logging
import os
import re

import yaml

from lokikit.download import find_grafana_binary, get_binaries


def create_dashboard(
    dashboard_name: str,
    fields: list[str],
    job_name: str | None = None,
    labels: dict[str, str] | None = None,
    field_types: dict[str, set[str]] | None = None,
) -> dict:
    """Create a Grafana dashboard JSON for the given fields.

    Args:
        dashboard_name: Name for the dashboard
        fields: List of log fields to include in the dashboard
        job_name: Optional job name for filtering logs
        labels: Optional additional labels for filtering logs
        field_types: Optional dictionary mapping field names to their detected types

    Returns:
        Dictionary containing the dashboard JSON definition
    """
    if not dashboard_name:
        dashboard_name = "Log Analysis Dashboard"

    if field_types is None:
        field_types = {}

    # Generate a unique ID for the dashboard
    uid = "lokikit-" + re.sub(r"[^a-z0-9-]", "-", dashboard_name.lower())

    # Base dashboard structure
    dashboard = {
        "uid": uid,
        "title": dashboard_name,
        "tags": ["lokikit", "generated"],
        "timezone": "browser",
        "editable": True,
        "liveNow": True,
        "style": "dark",
        "graphTooltip": 0,
        "time": {"from": "now-6h", "to": "now"},
        "panels": [],
        "refresh": "30s",
        "schemaVersion": 38,
        "version": 1,
        "annotations": {
            "list": [
                {
                    "builtIn": 1,
                    "datasource": {"type": "grafana", "uid": "-- Grafana --"},
                    "enable": True,
                    "hide": True,
                    "iconColor": "rgba(0, 211, 255, 1)",
                    "name": "Annotations & Alerts",
                    "type": "dashboard",
                }
            ]
        },
    }

    # Add a dashboard description with job and labels
    dashboard["description"] = "Generated by LokiKit\n\n"
    if job_name:
        dashboard["description"] += f"Job: {job_name}\n"
    if labels:
        dashboard["description"] += "\nLabels:\n"
        for k, v in labels.items():
            dashboard["description"] += f"- {k}: {v}\n"

    # Build the base Loki query
    base_query = build_loki_query(job_name, labels, fields)

    # Add a header row with description/metrics
    header_row_height = 3
    info_panel = {
        "id": 1,
        "title": "Dashboard Info",
        "type": "text",
        "gridPos": {"h": header_row_height, "w": 8, "x": 0, "y": 0},
        "options": {
            "mode": "markdown",
            "content": f"""### {dashboard_name}
This dashboard displays logs from **{job_name or "all sources"}**

*Generated by LokiKit*
""",
        },
    }
    dashboard["panels"].append(info_panel)

    # Add log volume panel
    log_rate_panel = {
        "id": 2,
        "title": "Log Volume",
        "type": "timeseries",
        "datasource": {"type": "loki", "uid": "lokikit"},
        "gridPos": {"h": header_row_height, "w": 16, "x": 8, "y": 0},
        "targets": [
            {
                "refId": "A",
                "expr": f"{base_query} | rate [5m]",
                "queryType": "range",
                "legendFormat": "Logs per second",
            }
        ],
        "options": {
            "tooltip": {"mode": "single", "sort": "none"},
            "legend": {"displayMode": "list", "placement": "bottom", "showLegend": True},
        },
        "fieldConfig": {
            "defaults": {
                "color": {"mode": "palette-classic"},
                "custom": {
                    "axisCenteredZero": False,
                    "axisColorMode": "text",
                    "axisLabel": "Logs/sec",
                    "axisPlacement": "auto",
                    "barAlignment": 0,
                    "drawStyle": "line",
                    "fillOpacity": 20,
                    "gradientMode": "none",
                    "hideFrom": {"legend": False, "tooltip": False, "viz": False},
                    "lineInterpolation": "smooth",
                    "lineWidth": 2,
                    "pointSize": 5,
                    "scaleDistribution": {"type": "linear"},
                    "showPoints": "never",
                    "spanNulls": False,
                    "stacking": {"group": "A", "mode": "none"},
                    "thresholdsStyle": {"mode": "off"},
                },
                "thresholds": {"mode": "absolute", "steps": [{"color": "green", "value": None}]},
                "unit": "ops",
            },
        },
    }
    dashboard["panels"].append(log_rate_panel)

    # Create a logs panel
    logs_panel = {
        "id": 3,
        "title": "Log Browser",
        "type": "logs",
        "datasource": {"type": "loki", "uid": "lokikit"},
        "gridPos": {"h": 9, "w": 24, "x": 0, "y": header_row_height},
        "targets": [{"refId": "A", "expr": base_query, "queryType": "range"}],
        "options": {
            "showLabels": False,
            "showTime": True,
            "sortOrder": "Descending",
            "wrapLogMessage": True,
            "dedupStrategy": "none",
            "enableLogDetails": True,
            "prettifyLogMessage": True,
        },
    }
    dashboard["panels"].append(logs_panel)

    # Current Y position for panels
    y_pos = header_row_height + 9  # After logs panel

    # Create a table panel for structured fields
    if fields:
        # Build a query with field extraction
        fields_query = build_loki_query(job_name, labels, fields)

        table_panel = {
            "id": 4,
            "title": "Structured Fields",
            "type": "table",
            "datasource": {"type": "loki", "uid": "lokikit"},
            "gridPos": {"h": 8, "w": 24, "x": 0, "y": y_pos},
            "targets": [
                {
                    "refId": "A",
                    "expr": fields_query,
                    "queryType": "instant",
                    "legendFormat": "",
                }
            ],
            "fieldConfig": {
                "defaults": {
                    "color": {"mode": "thresholds"},
                    "custom": {"align": "auto", "cellOptions": {"type": "auto"}, "filterable": True},
                    "mappings": [],
                    "thresholds": {"mode": "absolute", "steps": [{"color": "green", "value": None}]},
                },
                "overrides": [],
            },
            "options": {
                "footer": {"enablePagination": True, "fields": "", "reducer": ["sum"], "show": False},
                "showHeader": True,
            },
        }
        dashboard["panels"].append(table_panel)
        y_pos += 8

        # Create individual field panels for numeric/string fields (up to 4)
        numeric_fields = []
        string_fields = []

        # Only process up to 8 fields to avoid dashboard clutter
        for field in fields[:8]:
            # Check field type based on example data
            field_type = "string"  # Default to string
            for types in field_types.get(field, {"string"}):
                if types in ("int", "float", "number"):
                    field_type = "number"
                    numeric_fields.append(field)
                    break

            if field_type == "string" and field not in string_fields:
                string_fields.append(field)

        # Add panels for numeric fields (timeseries)
        if numeric_fields:
            panel_width = min(12, 24 // (len(numeric_fields) or 1))
            for i, field in enumerate(numeric_fields[:4]):  # Limit to 4 numeric fields
                x_pos = (i * panel_width) % 24
                if x_pos == 0 and i > 0:
                    y_pos += 8  # New row

                field_panel = {
                    "id": 10 + i,
                    "title": f"{field} over time",
                    "type": "timeseries",
                    "datasource": {"type": "loki", "uid": "lokikit"},
                    "gridPos": {"h": 8, "w": panel_width, "x": x_pos, "y": y_pos},
                    "targets": [
                        {
                            "refId": "A",
                            "expr": f'{base_query} | json | line_format "{{{{.extracted.{field}}}}}"',
                            "queryType": "range",
                            "legendFormat": field,
                        }
                    ],
                    "fieldConfig": {
                        "defaults": {
                            "color": {"mode": "palette-classic"},
                            "custom": {
                                "axisCenteredZero": False,
                                "axisColorMode": "text",
                                "axisLabel": "",
                                "axisPlacement": "auto",
                                "barAlignment": 0,
                                "drawStyle": "line",
                                "fillOpacity": 20,
                                "gradientMode": "none",
                                "hideFrom": {"legend": False, "tooltip": False, "viz": False},
                                "lineInterpolation": "smooth",
                                "lineWidth": 2,
                                "pointSize": 5,
                                "scaleDistribution": {"type": "linear"},
                                "showPoints": "never",
                                "spanNulls": False,
                                "stacking": {"group": "A", "mode": "none"},
                                "thresholdsStyle": {"mode": "off"},
                            },
                            "thresholds": {"mode": "absolute", "steps": [{"color": "green", "value": None}]},
                        },
                    },
                }
                dashboard["panels"].append(field_panel)

            # Move to next row if we added numeric panels
            if numeric_fields:
                y_pos += 8

        # Add a pie chart for string field distribution
        if string_fields:
            for i, field in enumerate(string_fields[:2]):  # Limit to 2 string fields
                field_panel = {
                    "id": 20 + i,
                    "title": f"{field} distribution",
                    "type": "piechart",
                    "datasource": {"type": "loki", "uid": "lokikit"},
                    "gridPos": {"h": 8, "w": 12, "x": i * 12, "y": y_pos},
                    "targets": [
                        {
                            "refId": "A",
                            "expr": (
                                f'{base_query} | json | line_format "{{{{.extracted.{field}}}}}" | pattern '
                                f'`(?P<value>.+)` | count_values "value" [10m]'
                            ),
                            "queryType": "instant",
                            "legendFormat": "{{value}}",
                        }
                    ],
                    "options": {
                        "displayLabels": ["name", "percent"],
                        "legend": {"displayMode": "table", "placement": "right", "values": ["value", "percent"]},
                        "pieType": "pie",
                        "reduceOptions": {"calcs": ["lastNotNull"], "fields": "", "values": False},
                        "tooltip": {"mode": "single", "sort": "none"},
                    },
                }
                dashboard["panels"].append(field_panel)

    return dashboard


def build_loki_query(
    job_name: str | None = None,
    labels: dict[str, str] | None = None,
    fields: list[str] | None = None,
) -> str:
    """
    Build a Loki query string from job name, labels, and fields.

    Args:
        job_name (str, optional): Job name for the selector
        labels (dict, optional): Additional labels for the selector
        fields (list, optional): Fields to extract from the logs

    Returns:
        str: The Loki query string
    """
    if job_name or labels:
        query_parts = ["{"]
        selectors = []

        if job_name:
            selectors.append(f'job="{job_name}"')

        if labels:
            for key, value in labels.items():
                selectors.append(f'{key}="{value}"')

        query_parts.append(", ".join(selectors))
        query_parts.append("}")

        # Add field extraction if needed
        if fields and len(fields) > 0:
            query_parts.append(" | json")

        # Add line format for selected fields if requested
        if fields and len(fields) > 0:
            extracted_fields = ", ".join([f"extracted.{field}" for field in fields])
            query_parts.append(f' | line_format "{{ {extracted_fields} }}"')

        return "".join(query_parts)
    else:
        base = "{}"
        if fields:
            base += " | json"
            extracted_fields = " ".join([f"{{{{.extracted.{f}}}}}" for f in fields])
            base += f' | line_format "{extracted_fields}"'
        return base


def save_dashboard(dashboard: dict, base_dir: str, dashboard_name: str) -> str:
    """Save the dashboard JSON to the appropriate location and configure Grafana provisioning.

    Args:
        dashboard: Dashboard JSON dictionary
        base_dir: Base directory for lokikit
        dashboard_name: Name for the dashboard file

    Returns:
        Path to the saved dashboard file
    """
    logger = logging.getLogger("lokikit")

    # Ensure dashboards directory exists
    dashboards_dir = os.path.join(base_dir, "dashboards")
    os.makedirs(dashboards_dir, exist_ok=True)

    # Clean dashboard name for filename
    clean_name = dashboard_name.lower().replace(" ", "_")
    if not clean_name.endswith(".json"):
        clean_name += ".json"

    # Save dashboard JSON
    dashboard_path = os.path.join(dashboards_dir, clean_name)
    with open(dashboard_path, "w") as f:
        json.dump(dashboard, f, indent=2)

    logger.info(f"Dashboard saved to {dashboard_path}")

    # Try to configure Grafana provisioning
    try:
        # Find Grafana home directory
        grafana_home = None
        binaries = get_binaries(base_dir)
        if binaries and "grafana" in binaries:
            grafana_bin = find_grafana_binary(
                base_dir, binaries["grafana"]["binary_name"], binaries["grafana"]["version"]
            )
            if grafana_bin:
                grafana_home = os.path.dirname(os.path.dirname(grafana_bin))
                logger.debug(f"Found Grafana home: {grafana_home}")

        if grafana_home:
            # Create provisioning directories if they don't exist
            grafana_prov_dir = os.path.join(grafana_home, "conf", "provisioning")
            grafana_dashboards_dir = os.path.join(grafana_prov_dir, "dashboards")
            os.makedirs(grafana_dashboards_dir, exist_ok=True)

            # Create dashboard provider configuration if it doesn't exist
            provider_config_path = os.path.join(grafana_dashboards_dir, "lokikit.yaml")

            # Check if provider config exists and needs updating
            update_provider = True
            if os.path.exists(provider_config_path):
                try:
                    with open(provider_config_path) as f:
                        existing_config = yaml.safe_load(f)

                    # Check if our dashboards path is already in the provider config
                    if existing_config and "providers" in existing_config:
                        for provider in existing_config["providers"]:
                            if (
                                provider.get("name") == "LokiKit"
                                and provider.get("options", {}).get("path") == dashboards_dir
                            ):
                                update_provider = False
                                break
                except Exception as e:
                    logger.warning(f"Error reading existing provider config: {e}")

            if update_provider:
                provider_config = {
                    "apiVersion": 1,
                    "providers": [
                        {
                            "name": "LokiKit",
                            "folder": "LokiKit",
                            "type": "file",
                            "updateIntervalSeconds": 10,
                            "allowUiUpdates": True,
                            "options": {"path": dashboards_dir, "foldersFromFilesStructure": False},
                        }
                    ],
                }
                with open(provider_config_path, "w") as f:
                    yaml.dump(provider_config, f, default_flow_style=False)
                logger.info(f"Created dashboard provider configuration at {provider_config_path}")
    except Exception as e:
        logger.warning(f"Unable to setup Grafana dashboard provisioning: {e}")
        logger.info("You will need to manually import the dashboard in Grafana.")

    return dashboard_path
