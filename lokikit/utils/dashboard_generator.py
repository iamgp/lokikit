"""Dashboard generation utilities for LokiKit.

This module provides functions for creating Grafana dashboards
based on log analysis results.
"""

import json
import os
import re
from typing import Any

# Unused imports that might be needed in the future:
# import uuid
# from typing import Optional
# from lokikit.config import ensure_dir


def detect_log_format(sample_logs: list[str]) -> dict:
    """Analyzes sample logs to detect the format structure.

    Args:
        sample_logs: List of sample log lines

    Returns:
        Dictionary with detection results including format type and other metadata
    """
    result = {
        "format_type": "unknown",
        "is_json": False,
        "has_level": False,
        "level_pattern": None,
        "message_pattern": None,
        "json_pattern": None,
    }

    if not sample_logs:
        return result

    # Check for various log formats based on samples
    json_count = 0
    level_patterns = [
        r"\| (DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE)\s+\|",  # Pipe separated format
        r"(DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE):",  # Level with colon
        r"\[(DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE)\]",  # Level in brackets
    ]

    for log in sample_logs:
        # Check if it's a pure JSON log
        if log.strip().startswith("{") and log.strip().endswith("}"):
            json_count += 1

        # Check for common log level patterns
        for pattern in level_patterns:
            if re.search(pattern, log):
                result["has_level"] = True
                result["level_pattern"] = pattern
                break

        # Check for embedded JSON objects
        if "{" in log and "}" in log:
            json_match = re.search(r"(\{.*\})", log)
            if json_match:
                result["json_pattern"] = r"(\{.*\})"

    # Determine format type based on the analysis
    if json_count > len(sample_logs) * 0.7:  # More than 70% are pure JSON
        result["format_type"] = "json"
        result["is_json"] = True
    elif result["has_level"] and result["json_pattern"]:
        result["format_type"] = "structured_with_json"
    elif result["has_level"]:
        result["format_type"] = "structured"

    return result


def create_dashboard(
    dashboard_name: str,
    fields: list[str],
    job_name: str,
    labels: dict[str, str] | None = None,
    field_types: dict[str, dict[str, Any]] | None = None
) -> dict[str, Any]:
    """Create a Grafana dashboard for logs.

    Args:
        dashboard_name: Name for the dashboard
        fields: List of fields to include in panels
        job_name: Promtail job name for the logs
        labels: Additional labels to filter logs
        field_types: Metadata about field types for optimized visualization

    Returns:
        Dashboard configuration dictionary
    """
    labels_dict = {} if labels is None else labels
    field_types_dict = {} if field_types is None else field_types

    # Generate a unique ID from the dashboard name
    uid = f"lokikit-{''.join(e for e in dashboard_name.lower() if e.isalnum() or e == '-')}"

    # Base query with labels
    base_query = f'{{job="{job_name}"'
    for k, v in labels_dict.items():
        base_query += f', {k}="{v}"'
    base_query += '}'

    # Dashboard structure
    dashboard = {
        "dashboard": {
            "uid": uid,
            "title": dashboard_name,
            "tags": ["lokikit", "generated"],
            "timezone": "browser",
            "editable": True,
            "liveNow": True,
            "style": "dark",
            "graphTooltip": 0,
            "time": {
                "from": "now-1h",
                "to": "now"
            },
            "panels": [],
            "refresh": "30s",
            "schemaVersion": 38,
            "version": 1,
            "annotations": {
                "list": [
                    {
                        "builtIn": 1,
                        "datasource": {
                            "type": "grafana",
                            "uid": "-- Grafana --"
                        },
                        "enable": True,
                        "hide": True,
                        "iconColor": "rgba(0, 211, 255, 1)",
                        "name": "Annotations & Alerts",
                        "type": "dashboard"
                    }
                ]
            },
            "description": f"Generated by LokiKit\n\nJob: {job_name}\n"
        },
        "overwrite": True,
        "message": f"Generated dashboard for {job_name}",
        "folderId": 0
    }

    # Add panels
    panels = []
    y_pos = 0
    panel_id = 1

    # Info panel
    info_panel = {
        "id": panel_id,
        "title": "Dashboard Info",
        "type": "text",
        "gridPos": {
            "h": 3,
            "w": 8,
            "x": 0,
            "y": y_pos
        },
        "options": {
            "mode": "markdown",
            "content": f"### {dashboard_name}\nThis dashboard displays logs from **{job_name}**\n\n*Generated by LokiKit*\n"
        }
    }
    panels.append(info_panel)
    panel_id += 1

    # Log volume panel
    volume_panel = {
        "id": panel_id,
        "title": "Log Volume",
        "type": "timeseries",
        "datasource": {
            "type": "loki",
            "uid": "lokikit"
        },
        "gridPos": {
            "h": 3,
            "w": 16,
            "x": 8,
            "y": y_pos
        },
        "targets": [
            {
                "refId": "A",
                "expr": f"sum(count_over_time({base_query}[5m])) by (job)",
                "queryType": "range",
                "legendFormat": "Logs per 5m"
            }
        ],
        "options": {
            "tooltip": {
                "mode": "single",
                "sort": "none"
            },
            "legend": {
                "displayMode": "list",
                "placement": "bottom",
                "showLegend": True
            }
        },
        "fieldConfig": {
            "defaults": {
                "color": {
                    "mode": "palette-classic"
                },
                "custom": {
                    "axisCenteredZero": False,
                    "axisColorMode": "text",
                    "axisLabel": "Logs/5m",
                    "axisPlacement": "auto",
                    "barAlignment": 0,
                    "drawStyle": "line",
                    "fillOpacity": 20,
                    "gradientMode": "none",
                    "hideFrom": {
                        "legend": False,
                        "tooltip": False,
                        "viz": False
                    },
                    "lineInterpolation": "smooth",
                    "lineWidth": 2,
                    "pointSize": 5,
                    "scaleDistribution": {
                        "type": "linear"
                    },
                    "showPoints": "never",
                    "spanNulls": False,
                    "stacking": {
                        "group": "A",
                        "mode": "none"
                    },
                    "thresholdsStyle": {
                        "mode": "off"
                    }
                },
                "thresholds": {
                    "mode": "absolute",
                    "steps": [
                        {
                            "color": "green",
                            "value": None
                        }
                    ]
                },
                "unit": "short"
            }
        }
    }
    panels.append(volume_panel)
    panel_id += 1
    y_pos += 3

    # Log browser panel
    log_browser_panel = {
        "id": panel_id,
        "title": "Log Browser",
        "type": "logs",
        "datasource": {
            "type": "loki",
            "uid": "lokikit"
        },
        "gridPos": {
            "h": 9,
            "w": 24,
            "x": 0,
            "y": y_pos
        },
        "targets": [
            {
                "refId": "A",
                "expr": base_query,
                "queryType": "range"
            }
        ],
        "options": {
            "showLabels": False,
            "showTime": True,
            "sortOrder": "Descending",
            "wrapLogMessage": True,
            "dedupStrategy": "none",
            "enableLogDetails": True,
            "prettifyLogMessage": True
        }
    }
    panels.append(log_browser_panel)
    panel_id += 1
    y_pos += 9

    # Add field-specific panels based on field types
    if fields and field_types_dict:
        # Process time series and categorical fields, leave the rest for the table
        time_series_fields = []
        categorical_fields = []
        for field in fields:
            if field in field_types_dict:
                field_info = field_types_dict[field]
                field_type = field_info.get("type", "unknown")
                cardinality_class = field_info.get("cardinality_class", "high")

                # Numeric fields with low cardinality are good for time series
                if field_type in ("integer", "float", "number") and cardinality_class != "high":
                    time_series_fields.append(field)
                # String/boolean fields with low/medium cardinality are good for categorical displays
                elif field_type in ("string", "boolean") and cardinality_class != "high":
                    categorical_fields.append(field)

        # Add categorical field panels (limit to 2 panels per row)
        for i, field in enumerate(categorical_fields[:4]):  # Limit to top 4
            # Determine panel position
            x_pos = 0 if i % 2 == 0 else 12
            if i % 2 == 0 and i > 0:
                y_pos += 8

            # Create LogQL query
            field_path = get_field_path(field)
            panel_query = generate_logql_query(base_query, field, field_types_dict, "json")

            # Create panel
            field_panel = {
                "id": panel_id,
                "title": f"{field.replace('_', ' ').title()} Distribution",
                "type": "piechart",
                "datasource": {
                    "type": "loki",
                    "uid": "lokikit"
                },
                "gridPos": {
                    "h": 8,
                    "w": 12,
                    "x": x_pos,
                    "y": y_pos
                },
                "targets": [
                    {
                        "refId": "A",
                        "expr": panel_query,
                        "queryType": "range",
                        "legendFormat": "{{" + field_path.replace(".", "_") + "}}"
                    }
                ],
                "options": {
                    "displayLabels": ["name", "percent"],
                    "legend": {
                        "displayMode": "table",
                        "placement": "right",
                        "values": ["value", "percent"]
                    },
                    "pieType": "pie",
                    "reduceOptions": {
                        "calcs": ["lastNotNull"],
                        "fields": "",
                        "values": False
                    },
                    "tooltip": {
                        "mode": "single",
                        "sort": "none"
                    }
                }
            }
            panels.append(field_panel)
            panel_id += 1

        # Add time series panels (if we have any)
        if time_series_fields:
            if categorical_fields:
                y_pos += 8  # Move to next row if we added categorical panels

            # Create time series panel
            field = time_series_fields[0]  # Just use the first numeric field for now
            field_path = get_field_path(field)

            # Create panel
            ts_panel = {
                "id": panel_id,
                "title": f"{field.replace('_', ' ').title()} Over Time",
                "type": "timeseries",
                "datasource": {
                    "type": "loki",
                    "uid": "lokikit"
                },
                "gridPos": {
                    "h": 8,
                    "w": 12,
                    "x": 0,
                    "y": y_pos
                },
                "targets": [
                    {
                        "refId": "A",
                        "expr": f"{base_query} | json | __error__=\"\" | unwrap {field_path} | quantile_over_time(0.95, [1m])",
                        "queryType": "range",
                        "legendFormat": "95th percentile"
                    },
                    {
                        "refId": "B",
                        "expr": f"{base_query} | json | __error__=\"\" | unwrap {field_path} | avg_over_time([1m])",
                        "queryType": "range",
                        "legendFormat": "Average"
                    }
                ],
                "options": {
                    "tooltip": {
                        "mode": "multi",
                        "sort": "none"
                    },
                    "legend": {
                        "displayMode": "list",
                        "placement": "bottom",
                        "showLegend": True
                    }
                },
                "fieldConfig": {
                    "defaults": {
                        "color": {
                            "mode": "palette-classic"
                        },
                        "custom": {
                            "axisCenteredZero": False,
                            "axisColorMode": "text",
                            "axisLabel": field.replace("_", " ").title(),
                            "axisPlacement": "auto",
                            "barAlignment": 0,
                            "drawStyle": "line",
                            "fillOpacity": 20,
                            "gradientMode": "none",
                            "hideFrom": {
                                "legend": False,
                                "tooltip": False,
                                "viz": False
                            },
                            "lineInterpolation": "smooth",
                            "lineWidth": 2,
                            "pointSize": 5,
                            "scaleDistribution": {
                                "type": "linear"
                            },
                            "showPoints": "never",
                            "spanNulls": False,
                            "stacking": {
                                "group": "A",
                                "mode": "none"
                            },
                            "thresholdsStyle": {
                                "mode": "off"
                            }
                        },
                        "thresholds": {
                            "mode": "absolute",
                            "steps": [
                                {
                                    "color": "green",
                                    "value": None
                                }
                            ]
                        },
                        "unit": "short" if field_types_dict[field].get("type") == "integer" else "number"
                    }
                }
            }
            panels.append(ts_panel)
            panel_id += 1

            # Add a bar chart for another field if available
            if len(categorical_fields) > 0:
                field = categorical_fields[0]
                field_path = get_field_path(field)
                panel_query = generate_logql_query(base_query, field, field_types_dict, "json")

                bar_panel = {
                    "id": panel_id,
                    "title": f"{field.replace('_', ' ').title()} Distribution",
                    "type": "barchart",
                    "datasource": {
                        "type": "loki",
                        "uid": "lokikit"
                    },
                    "gridPos": {
                        "h": 8,
                        "w": 12,
                        "x": 12,
                        "y": y_pos
                    },
                    "targets": [
                        {
                            "refId": "A",
                            "expr": panel_query,
                            "queryType": "range",
                            "legendFormat": "{{" + field_path.replace(".", "_") + "}}"
                        }
                    ],
                    "options": {
                        "orientation": "horizontal",
                        "legend": {
                            "displayMode": "list",
                            "placement": "bottom",
                            "showLegend": True
                        },
                        "tooltip": {
                            "mode": "single",
                            "sort": "none"
                        }
                    },
                    "fieldConfig": {
                        "defaults": {
                            "color": {
                                "mode": "palette-classic"
                            },
                            "custom": {
                                "axisCenteredZero": False,
                                "axisColorMode": "text",
                                "axisLabel": "Count",
                                "axisPlacement": "auto",
                                "barAlignment": 0,
                                "fillOpacity": 80,
                                "gradientMode": "none",
                                "hideFrom": {
                                    "legend": False,
                                    "tooltip": False,
                                    "viz": False
                                },
                                "lineWidth": 1,
                                "scaleDistribution": {
                                    "type": "linear"
                                }
                            },
                            "thresholds": {
                                "mode": "absolute",
                                "steps": [
                                    {
                                        "color": "green",
                                        "value": None
                                    }
                                ]
                            },
                            "unit": "short"
                        }
                    }
                }
                panels.append(bar_panel)
                panel_id += 1

        y_pos += 8  # Move down for the structured table

        # Structured Log Table with improved field handling
        # Determine the log format parser to use
        parser_expr = "| json"
        if "format_detected" in field_types_dict and field_types_dict["format_detected"] == "logfmt":
            parser_expr = "| logfmt"

        # Create the table query
        table_query = f"{base_query} {parser_expr} | __error__=\"\""

        # Create the table
        table_panel = {
            "id": panel_id,
            "title": "Structured Log Table",
            "type": "table",
            "datasource": {
                "type": "loki",
                "uid": "lokikit"
            },
            "gridPos": {
                "h": 8,
                "w": 24,
                "x": 0,
                "y": y_pos
            },
            "targets": [
                {
                    "refId": "A",
                    "expr": table_query,
                    "queryType": "range"
                }
            ],
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "custom": {
                        "align": "auto",
                        "cellOptions": {
                            "type": "auto"
                        },
                        "filterable": True,
                        "inspect": False
                    },
                    "mappings": [],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": None
                            }
                        ]
                    }
                },
                "overrides": []
            },
            "options": {
                "footer": {
                    "enablePagination": True,
                    "fields": "",
                    "reducer": ["sum"],
                    "show": False
                },
                "showHeader": True,
                "sortBy": [
                    {
                        "desc": True,
                        "displayName": "Time"
                    }
                ]
            }
        }

        # Better field configuration
        # We need to detect if there's a record.* structure and handle it appropriately
        nested_fields = False

        for field in fields:
            if "." in field:
                nested_fields = True
                break

        # Check if we need to add field overrides to show specific record.* fields
        if nested_fields:
            # Add field overrides to show important fields and not hide nested fields
            selected_fields = []

            # First gather all the top-level parent fields and child fields
            parent_fields = set()
            nested_field_mapping = {}

            for field in fields:
                parts = field.split('.')
                if len(parts) > 1:
                    parent = parts[0]
                    parent_fields.add(parent)

                    # Store mapping from field path to display name
                    field_path = field
                    display_name = field.replace(".", "_")
                    nested_field_mapping[field_path] = display_name

                    # Add the important parent and child fields
                    selected_fields.append(field)

            # Add all parent fields if we have nested fields
            for parent in parent_fields:
                if parent not in selected_fields:
                    selected_fields.append(parent)

            # Add specific overrides to make nested fields visible
            if nested_field_mapping:
                # First add an override to format the Time column
                table_panel["fieldConfig"]["overrides"].append({
                    "matcher": {
                        "id": "byName",
                        "options": "Time"
                    },
                    "properties": [
                        {
                            "id": "custom.width",
                            "value": 170
                        }
                    ]
                })

                # For each nested field, add specific override to ensure it's visible
                for field_path, display_name in nested_field_mapping.items():
                    table_panel["fieldConfig"]["overrides"].append({
                        "matcher": {
                            "id": "byName",
                            "options": display_name
                        },
                        "properties": [
                            {
                                "id": "custom.hidden",
                                "value": False
                            },
                            {
                                "id": "displayName",
                                "value": field_path.replace(".", " > ")
                            }
                        ]
                    })

                # Also add special handling for common fields
                common_fields = ["level", "message", "timestamp", "time", "msg"]
                for field in common_fields:
                    if field in fields:
                        table_panel["fieldConfig"]["overrides"].append({
                            "matcher": {
                                "id": "byName",
                                "options": field
                            },
                            "properties": [
                                {
                                    "id": "custom.width",
                                    "value": 300 if field == "message" or field == "msg" else 150
                                },
                                {
                                    "id": "custom.hidden",
                                    "value": False
                                }
                            ]
                        })

        panels.append(table_panel)

    # Update the dashboard with panels
    dashboard["dashboard"]["panels"] = panels

    return dashboard


def save_dashboard(dashboard: dict[str, Any], base_dir: str, dashboard_name: str) -> str:
    """Save a dashboard to a file.

    Args:
        dashboard: Dashboard configuration
        base_dir: Base directory for saving
        dashboard_name: Name of the dashboard

    Returns:
        Path to the saved dashboard file
    """
    # Create dashboards directory if it doesn't exist
    dashboards_dir = os.path.join(base_dir, "dashboards")
    os.makedirs(dashboards_dir, exist_ok=True)

    # Clean the filename
    filename = "".join(c if c.isalnum() or c in "._- " else "_" for c in dashboard_name.lower())
    filename = filename.replace(" ", "_")

    # Save the dashboard to a file
    dashboard_path = os.path.join(dashboards_dir, f"{filename}.json")
    with open(dashboard_path, "w") as f:
        json.dump(dashboard, f, indent=2)

    return dashboard_path


def get_field_path(field: str) -> str:
    """Convert a field name to a LogQL-compatible field path (always use full path)."""
    return field  # Always use the full path, including nested fields


def generate_logql_query(
    base_query: str,
    field: str,
    field_types: dict[str, dict[str, Any]],
    log_format: str = "json"
) -> str:
    """Generate a LogQL query for a field based on its type and log format."""
    field_path = get_field_path(field)
    field_info = field_types.get(field, {})
    field_type = field_info.get("type", "string")
    display_field = field_path.replace(".", "_")

    # Always use | json for your log format (pure JSON per line)
    pipeline = "| json"

    if field_type in ("string", "boolean"):
        return f"topk(10, count_over_time({base_query} {pipeline} | __error__=\"\" | unwrap {field_path} [10m])) by ({display_field})"
    elif field_type in ("integer", "float", "number"):
        return f"{base_query} {pipeline} | __error__=\"\" | unwrap {field_path} | avg_over_time([10m]) by ({display_field})"
    else:
        return f"topk(10, count_over_time({base_query} {pipeline} | __error__=\"\" | unwrap {field_path} [10m])) by ({display_field})"
